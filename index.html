<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>地監冒險 (含商店功能)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* General Body and Container Styles */
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            box-sizing: border-box;
        }
        .game-container {
            background-color: #2d3748;
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            max-width: 600px;
            width: 100%;
            padding: 1.5rem;
            border: 2px solid #4a5568;
            display: flex;
            flex-direction: column;
            gap: 0.75rem; 
        }
        .header h2 {
            font-size: 2rem; 
            font-weight: 700;
            color: #a0aec0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }

        /* Status, Stats, and Health Bar */
        .status-bar {
            display: flex; flex-wrap: wrap; justify-content: center;
            background-color: #4a5568; padding: 0.25rem; border-radius: 0.75rem;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3); border: 1px solid #5a6478;
        }
        .stats-grid {
            display: grid; grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem; text-align: center; font-size: 0.9rem;
        }
        .stat-item {
            background-color: #3a4352; padding: 0.5rem; border-radius: 0.5rem;
        }
        .stat-item .value { font-weight: 700; font-size: 1.1rem; color: #e2e8f0; }
        .stat-item .label { font-size: 0.8rem; color: #a0aec0; }
        .health-bar-wrapper {
            width: 100%; margin: 0.5rem 0; background-color: #3a4352;
            border-radius: 0.75rem; padding: 0.5rem; position: relative;
            height: 2.5rem; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4);
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }
        .health-bar-container {
            position: absolute; left: 0; top: 0; width: 100%; height: 100%;
            background-color: #555; border-radius: 0.5rem; overflow: hidden;
        }
        .health-bar-fill {
            height: 100%; background: linear-gradient(to right, #e53e3e, #c53030);
            width: 100%; transition: width 0.5s ease-in-out; border-radius: 0.5rem;
        }
        .health-bar-text {
            position: absolute; color: white; font-weight: bold; text-shadow: 1px 1px 2px black;
        }

        /* Game Output & Buttons */
        .game-output {
            background-color: #1a202c; border: 1px solid #4a5568; border-radius: 0.75rem;
            padding: 1rem; height: 125px; overflow-y: auto; white-space: pre-wrap;
            word-wrap: break-word; font-size: 1rem; line-height: 1.5; color: #e2e8f0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .boss-encounter {
            color: #f56565;
            font-weight: bold;
            text-align: center;
        }
        .button-group {
            display: flex; flex-wrap: wrap; gap: 0.75rem; justify-content: center;
        }
        .game-button {
            background-color: #4299e1; color: white; padding: 0.75rem 1.5rem;
            border-radius: 0.75rem; font-size: 1.1rem; font-weight: 700;
            cursor: pointer; transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
            border: none; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            flex-grow: 1; min-width: 120px;
        }
        .game-button:hover {
            background-color: #3182ce; transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.4);
        }
        .game-button:disabled {
            background-color: #a0aec0; cursor: not-allowed; transform: none; box-shadow: none;
        }
        .red-button { background-color: #e53e3e; } .red-button:hover { background-color: #c53030; }
        .green-button { background-color: #48bb78; } .green-button:hover { background-color: #38a169; }
        .gray-button { background-color: #718096; } .gray-button:hover { background-color: #4a5568; }

        /* List & Item Styles (Inventory, Equipped, Shop) */
        .list-container {
            background-color: #1a202c; border: 1px solid #4a5568; border-radius: 0.75rem;
            padding: 1rem; max-height: 250px; overflow-y: auto;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3); margin-top: 1rem;
        }
        .list-container ul { list-style: none; padding: 0; margin: 0; }
        .list-container li {
            padding: 0.5rem; border-bottom: 1px dashed #4a5568; display: flex;
            justify-content: space-between; align-items: center; transition: background-color 0.2s ease;
        }
        .list-container li:hover { background-color: #3a4352; border-radius: 0.5rem; }
        .list-container li:last-child { border-bottom: none; }
        .list-container li .item-name { flex-grow: 1; }
        .list-container li .item-actions { display: flex; gap: 0.5rem; flex-shrink: 0; }
        .list-container li button, .shop-action-btn {
            color: white; padding: 0.25rem 0.75rem; border-radius: 0.5rem;
            font-size: 0.9rem; cursor: pointer; transition: background-color 0.2s ease; border: none;
        }
        .equip-btn { background-color: #63b3ed; } .equip-btn:hover { background-color: #4299e1; }
        .use-btn { background-color: #a0aec0; } .use-btn:hover { background-color: #718096; }

        /* Modal Styles (Game Over, Equip, Shop) */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8); display: flex;
            justify-content: center; align-items: center; z-index: 1000;
        }
        .modal-content {
            background-color: #2d3748; padding: 2rem; border-radius: 1.0rem;
            text-align: center; box-shadow: 0 10px 20px rgba(0, 0, 0, 0.7);
            border: 2px solid #4a5568; max-width: 90%; width: 500px;
        }
        .modal-content h2 { font-size: 2rem; color: #a0aec0; margin-bottom: 1rem; }
        .modal-content p { font-size: 1.2rem; margin-bottom: 1.5rem; }
        
        /* Equip Confirmation Modal */
        .comparison-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; text-align: left; margin-bottom: 1.5rem; }
        .comparison-grid h3 { font-weight: bold; color: #718096; border-bottom: 1px solid #4a5568; padding-bottom: 0.5rem; }
        .stat-change-loss { color: #f56565; }
        .stat-change-gain { color: #48bb78; }
        
        /* Shop Modal Styles */
        .shop-tabs { display: flex; gap: 0.5rem; margin-bottom: 1rem; border-bottom: 2px solid #4a5568; }
        .shop-tab {
            padding: 0.75rem 1.5rem; border-radius: 0.5rem 0.5rem 0 0; background-color: #4a5568;
            cursor: pointer; transition: background-color 0.2s; font-weight: bold;
        }
        .shop-tab.active { background-color: #3a4352; color: #e2e8f0; }
        .shop-item-list { max-height: 300px; overflow-y: auto; text-align: left; }
        .shop-item { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 0.5rem; border-bottom: 1px dashed #4a5568; }
        .shop-item:last-child { border-bottom: none; }
        .shop-item-info { flex-grow: 1; }
        .shop-item-name { font-weight: bold; }
        .shop-item-price { color: #f6e05e; }
        .buy-btn { background-color: #48bb78; } .buy-btn:hover:not(:disabled) { background-color: #38a169; }
        .sell-btn { background-color: #f6e05e; color: #1a202c; } .sell-btn:hover { background-color: #ecc94b; }
        .shop-action-btn:disabled { background-color: #718096; cursor: not-allowed; }
    </style>
</head>
<body>
    <div id="gameContainer" class="game-container">
        <!-- Header and Health Bar -->
        <div class="header text-center mb-1"><h2>地監冒險</h2></div>
        <div class="status-bar">
            <div class="health-bar-wrapper">
                <div id="playerHealthBarContainer" class="health-bar-container">
                    <div id="playerHealthBarFill" class="health-bar-fill"></div>
                </div>
                <div id="playerHealthText" class="health-bar-text"></div>
            </div>
        </div>

        <!-- Game Output and Action Buttons -->
        <div id="gameOutput" class="game-output"></div>
        <div id="buttonGroup" class="button-group"></div>
        <div id="inventoryDisplay" class="list-container hidden"></div>
        
        <!-- Player Stats Grid -->
        <div class="stats-grid mt-4">
            <div class="stat-item"><div id="playerGold" class="value"></div><div class="label">金幣</div></div>
            <div class="stat-item"><div id="playerAttack" class="value"></div><div class="label">攻擊力</div></div>
            <div class="stat-item"><div id="playerDefense" class="value"></div><div class="label">防禦力</div></div>
            <div class="stat-item"><div id="playerLevel" class="value"></div><div class="label">等級</div></div>
            <div class="stat-item"><div id="playerXP" class="value"></div><div class="label">經驗值</div></div>
            <div class="stat-item"><div id="currentFloor" class="value"></div><div class="label">樓層</div></div>
        </div>

        <!-- Equipped Items Display -->
        <div id="equippedItemsDisplay" class="list-container">
            <h3 class="text-xl font-bold mb-2 text-center text-gray-300">
                已裝備物品
                <button id="toggleEquippedButton" class="text-sm px-2 py-1 rounded-md bg-blue-600 hover:bg-blue-700 transition-colors ml-2">展開</button>
            </h3>
            <div id="equippedListContainer" class="hidden"><ul id="equippedList"></ul></div>
        </div>
    </div>

    <!-- MODALS SECTION -->
    <div id="gameOverModal" class="modal hidden">
        <div class="modal-content">
            <h2>遊戲結束！</h2>
            <p id="gameOverMessage"></p>
            <button id="restartButton" class="game-button green-button">重新開始</button>
        </div>
    </div>
    <div id="equipConfirmModal" class="modal hidden">
        <div class="modal-content">
            <h2 id="equipModalTitle">確認裝備</h2>
            <div id="equipComparison" class="comparison-grid"></div>
            <div class="flex justify-center gap-4">
                <button id="confirmEquipButton" class="game-button green-button">確認</button>
                <button id="cancelEquipButton" class="game-button gray-button">取消</button>
            </div>
        </div>
    </div>
    <div id="shopModal" class="modal hidden">
        <div class="modal-content">
            <h2>商店</h2>
            <div class="shop-tabs">
                <div id="buyTab" class="shop-tab active" onclick="Game.renderShop('buy')">購買</div>
                <div id="sellTab" class="shop-tab" onclick="Game.renderShop('sell')">販賣</div>
            </div>
            <div id="shopItemList" class="shop-item-list"></div>
            <button id="closeShopButton" class="game-button gray-button mt-6">離開商店</button>
        </div>
    </div>

    <script>
    const Game = {
        DOM: {},
        CONSTANTS: {
            MAX_DUNGEON_FLOOR: 7,
            EXPLORATIONS_PER_FLOOR: 10,
            MONSTER_HP_SCALING: 0.2,
            MONSTER_ATTACK_SCALING: 0.1,
            SHOP_BUY_PRICE_MULTIPLIER: 2,
        },
        state: {
            player: null,
            currentMonster: null,
            gamePhase: 'start',
            lastMajorPhase: 'start',
            currentShopTab: 'buy',
        },
        data: {
            monsters: {},
            items: {},
            floorMonsterPools: {},
            shopInventory: [],
        },

        // **修改**：初始化流程改為 async/await 模式
        async init() {
            try {
                this.cacheDOMElements();
                await this.loadData();
                this.bindEvents();
                this.checkForSave();
            } catch (error) {
                console.error("遊戲初始化失敗:", error);
                document.body.innerHTML = `<div style="color: red; text-align: center; margin-top: 50px; font-size: 1.5rem;">遊戲資料載入失敗: ${error.message}</div>`;
            }
        },

        cacheDOMElements() {
            const ids = [
                'playerHealthBarFill', 'playerHealthText', 'equippedList', 'playerGold', 'playerAttack',
                'playerDefense', 'playerLevel', 'playerXP', 'currentFloor',
                'gameOutput', 'buttonGroup', 'inventoryDisplay', 'gameOverModal',
                'gameOverMessage', 'restartButton', 'toggleEquippedButton', 'equippedListContainer',
                'equipConfirmModal', 'equipModalTitle', 'equipComparison', 'confirmEquipButton', 'cancelEquipButton',
                'shopModal', 'buyTab', 'sellTab', 'shopItemList', 'closeShopButton'
            ];
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (!el) throw new Error(`Critical DOM element not found: #${id}`);
                this.DOM[id] = el;
            });
        },
        
        async loadData() {
            try {
                const [monsterResponse, itemResponse, floorResponse, shopResponse] = await Promise.all([
                    fetch('monsters.json'),
                    fetch('items.json'),
                    fetch('dungeon_floors.json'),
                    fetch('shop.json')
                ]);

                if (!monsterResponse.ok) throw new Error('無法載入 monsters.json');
                if (!itemResponse.ok) throw new Error('無法載入 items.json');
                if (!floorResponse.ok) throw new Error('無法載入 dungeon_floors.json');
                if (!shopResponse.ok) throw new Error('無法載入 shop.json');

                const [monsterData, itemData, floorData, shopData] = await Promise.all([
                    monsterResponse.json(),
                    itemResponse.json(),
                    floorResponse.json(),
                    shopResponse.json()
                ]);

                this.data.monsters = monsterData;
                this.data.items = itemData;
                this.data.floorMonsterPools = floorData;
                this.data.shopInventory = shopData;

            } catch (error) {
                console.error("載入遊戲資料時發生錯誤:", error);
                throw error;
            }
        },

        bindEvents() {
            this.DOM.restartButton.addEventListener('click', () => this.resetGame(true)); // Pass true to indicate a manual restart
            this.DOM.toggleEquippedButton.addEventListener('click', () => this.toggleEquippedDisplay());
            this.DOM.cancelEquipButton.addEventListener('click', () => this.DOM.equipConfirmModal.classList.add('hidden'));
            this.DOM.closeShopButton.addEventListener('click', () => this.closeShop());
        },

        checkForSave() {
            if (localStorage.getItem('lineageGameSave')) {
                this.setOutput('發現之前的遊戲存檔。');
                this.showStartOptions(true);
            } else {
                this.resetGame();
            }
        },

        resetGame(isManualRestart = false) {
            if (isManualRestart) {
                this.deleteSave();
            }
            this.state.player = this.getInitialPlayerState();
            this.state.currentMonster = null;
            this.DOM.gameOverModal.classList.add('hidden');
            this.setOutput('你已在木人場訓練有成！準備好進入地監冒險了嗎?');
            this.setPhase('start');
        },

        getInitialPlayerState() {
            const level = 5;
            const maxHp = 100 + (level - 1) * 10;
            return {
                hp: maxHp, maxHp: maxHp, gold: 500,
                baseAttack: 10 + (level - 1) * 2,
                baseDefense: 0 + (level - 1) * 1,
                level: level, xp: 0,
                xpToNextLevel: this.getXpRequiredForLevel(level),
                inventory: [],
                equipped: { head: null, body: null, legs: null, rightHand: null, leftHand: null },
                currentFloor: 1, explorationsOnFloor: 0,
            };
        },

        updateUI() { this.updateStatus(); },
        updateStatus() {
            const p = this.state.player;
            const stats = this.calculatePlayerStats();
            const hpPercentage = (p.hp / p.maxHp) * 100;
            this.DOM.playerHealthBarFill.style.width = `${hpPercentage}%`;
            this.DOM.playerHealthText.textContent = `${p.hp} / ${p.maxHp}`;
            this.DOM.playerGold.textContent = p.gold;
            this.DOM.playerAttack.textContent = stats.attack;
            this.DOM.playerDefense.textContent = stats.defense;
            this.DOM.playerLevel.textContent = p.level;
            this.DOM.playerXP.textContent = `${p.xp} / ${p.xpToNextLevel}`;
            this.DOM.currentFloor.textContent = p.currentFloor;
            this.renderEquippedItems();
        },
        
        renderButtons(buttonArray) {
            this.DOM.buttonGroup.innerHTML = '';
            buttonArray.forEach(btn => {
                const button = document.createElement('button');
                button.textContent = btn.text;
                button.className = btn.className || 'game-button';
                button.onclick = btn.action;
                button.disabled = btn.disabled || false;
                this.DOM.buttonGroup.appendChild(button);
            });
        },

        renderEquippedItems() {
            this.DOM.equippedList.innerHTML = '';
            const slotOrder = { head: '頭部', body: '身體', legs: '腿部', rightHand: '右手', leftHand: '左手' };
            for(const slotKey in slotOrder) {
                const li = document.createElement('li');
                const itemKey = this.state.player.equipped[slotKey];
                let text = `${slotOrder[slotKey]}: `;
                if (itemKey) {
                    text += this.getFormattedItemName(itemKey);
                    const unequipBtn = document.createElement('button');
                    unequipBtn.textContent = '卸下';
                    unequipBtn.className = 'equip-btn';
                    unequipBtn.onclick = () => this.unequipItem(slotKey);
                    li.innerHTML = `<span class="item-name">${text}</span>`;
                    li.appendChild(unequipBtn);
                } else {
                    text += '無';
                    li.innerHTML = `<span class="item-name">${text}</span>`;
                }
                this.DOM.equippedList.appendChild(li);
            }
        },

        toggleEquippedDisplay() {
            const isHidden = this.DOM.equippedListContainer.classList.toggle('hidden');
            this.DOM.toggleEquippedButton.textContent = isHidden ? '展開' : '收合';
        },

        setPhase(newPhase) {
            this.state.gamePhase = newPhase;
            this.DOM.inventoryDisplay.classList.add('hidden');
            switch (newPhase) {
                case 'start': this.showStartOptions(); break;
                case 'village': this.showVillageOptions(); break;
                case 'explore': this.showExploreOptions(); break;
                case 'combat': this.showCombatOptions(); break;
                case 'shop': this.showShop(); break;
            }
            this.updateUI();
        },
        
        showStartOptions(hasSave = false) {
            let buttons = [];
            if (hasSave) {
                buttons.push({ text: '繼續遊戲', action: () => this.loadGame(), className: 'game-button green-button' });
                buttons.push({ text: '新遊戲', action: () => this.resetGame(true), className: 'game-button gray-button' });
            } else {
                buttons.push({ text: '進入地監', action: () => this.enterDungeon() });
            }
            this.renderButtons(buttons);
        },

        enterDungeon() {
            this.setOutput(`你踏入了地監地下 ${this.state.player.currentFloor} 層... 周圍一片漆黑，你感覺到危險潛伏著。`);
            this.setPhase('explore');
        },
        showVillageOptions() {
            this.setOutput('你回到了村莊，這裡感覺安全多了。');
            this.renderButtons([
                { text: '繼續冒險', action: () => this.enterDungeon() },
                { text: '商店', action: () => { this.state.lastMajorPhase = 'village'; this.setPhase('shop'); } },
                { text: '背包', action: () => this.showInventory() },
                { text: '休息', action: () => this.restInVillage() },
            ]);
        },
        showExploreOptions() {
            this.renderButtons([
                { text: '探索', action: () => this.exploreDungeon() },
                { text: '背包', action: () => this.showInventory() },
                { text: '回村', action: () => this.returnToVillage() },
            ]);
        },

        exploreDungeon() {
            this.state.player.explorationsOnFloor++;
            if (this.state.player.explorationsOnFloor >= this.CONSTANTS.EXPLORATIONS_PER_FLOOR && this.state.player.currentFloor < this.CONSTANTS.MAX_DUNGEON_FLOOR) {
                this.state.player.currentFloor++;
                this.state.player.explorationsOnFloor = 0;
                this.appendOutput(`你已深入地監，進入了地下 ${this.state.player.currentFloor} 層！`);
            }

            const rand = Math.random();
            if (rand < 0.6) {
                const pool = this.data.floorMonsterPools[this.state.player.currentFloor] || this.data.floorMonsterPools[1];
                const monsterKey = pool[Math.floor(Math.random() * pool.length)];
                const baseMonster = this.data.monsters[monsterKey];
                
                this.state.currentMonster = { ...baseMonster };
                this.state.currentMonster.hp = Math.round(baseMonster.hp * (1 + (this.state.player.currentFloor - 1) * this.CONSTANTS.MONSTER_HP_SCALING));
                this.state.currentMonster.attack = Math.round(baseMonster.attack * (1 + (this.state.player.currentFloor - 1) * this.CONSTANTS.MONSTER_ATTACK_SCALING));

                const m = this.state.currentMonster;
                const formattedName = this.getFormattedMonsterName(m);
                let encounterMessage;
                if (m.monsterType === 'boss') {
                    encounterMessage = `<div class="boss-encounter">你遭遇到一股強大的壓迫感！<br> ${formattedName} (Lv.${m.level}) 出現在你的面前！</div>`;
                } else {
                    encounterMessage = `你遇到了一隻 ${formattedName} (Lv.${m.level})！`;
                }
                this.setOutput(encounterMessage, true);
                this.setPhase('combat');
            } else if (rand < 0.75) {
                this.findChest(); // Replaced findItem()
                this.setPhase('explore');
            } else {
                this.appendOutput('你繼續探索，但什麼也沒發現...');
                this.setPhase('explore');
            }
            this.updateUI();
        },

        findChest() {
            const floor = this.state.player.currentFloor;
            const rand = Math.random();
            let chestType;

            // Determine chest type based on floor
            if (floor <= 2) { // Floors 1-2
                chestType = rand < 0.8 ? 'wooden' : 'sturdy'; // 80% wooden, 20% sturdy
            } else if (floor <= 4) { // Floors 3-4
                if (rand < 0.4) chestType = 'wooden'; // 40% wooden
                else if (rand < 0.8) chestType = 'sturdy'; // 40% sturdy
                else chestType = 'ornate'; // 20% ornate
            } else { // Floors 5-7
                if (rand < 0.4) chestType = 'sturdy'; // 40% sturdy
                else if (rand < 0.8) chestType = 'ornate'; // 40% ornate
                else chestType = 'legendary'; // 20% legendary
            }
            
            const chestDisplayNames = {
                wooden: '木製寶箱',
                sturdy: '堅固寶箱',
                ornate: '華麗寶箱',
                legendary: '傳說寶箱'
            };
            const chestName = chestDisplayNames[chestType];
            const formattedChestName = this.getFormattedChestName(chestType, chestName);

            this.appendOutput(`你發現了一個 ${formattedChestName}！`, true);
            this.openChest(chestType);
        },

        openChest(chestType) {
            const rand = Math.random();
            let itemRarity;

            // Determine item rarity based on chest type
            switch (chestType) {
                case 'wooden': // 80% common, 20% uncommon
                    itemRarity = rand < 0.8 ? 'common' : 'uncommon';
                    break;
                case 'sturdy': // 40% common, 40% rare, 20% uncommon
                    if (rand < 0.4) itemRarity = 'common';
                    else if (rand < 0.8) itemRarity = 'rare';
                    else itemRarity = 'uncommon';
                    break;
                case 'ornate': // 40% rare, 40% uncommon, 20% legendary
                    if (rand < 0.4) itemRarity = 'rare';
                    else if (rand < 0.8) itemRarity = 'uncommon';
                    else itemRarity = 'legendary';
                    break;
                case 'legendary': // 40% legendary, 60% rare
                    itemRarity = rand < 0.4 ? 'legendary' : 'rare';
                    break;
            }

            const foundItemKey = this.getRandomItemByRarity(itemRarity);

            if (foundItemKey) {
                this.state.player.inventory.push(foundItemKey);
                this.appendOutput(`你打開寶箱，獲得了 ${this.getFormattedItemName(foundItemKey)}！`, true);
            } else {
                this.appendOutput('寶箱是空的...真是太不幸了。');
            }
        },

        getRandomItemByRarity(rarity) {
            const rarityOrder = ['legendary', 'rare', 'uncommon', 'common'];
            let searchIndex = rarityOrder.indexOf(rarity);
            let itemsOfRarity = [];

            while (searchIndex < rarityOrder.length && itemsOfRarity.length === 0) {
                const currentRarity = rarityOrder[searchIndex];
                itemsOfRarity = Object.keys(this.data.items).filter(key => {
                    const item = this.data.items[key];
                    return item.sell && (item.rarity || 'common') === currentRarity;
                });
                searchIndex++;
            }

            if (itemsOfRarity.length > 0) {
                return itemsOfRarity[Math.floor(Math.random() * itemsOfRarity.length)];
            }
            return null;
        },

        showCombatOptions() {
            this.renderButtons([
                { text: '攻擊', action: () => this.playerAttack(), className: 'game-button red-button' },
                { text: '背包', action: () => this.showInventory() },
                { text: '逃跑', action: () => this.runAway() },
            ]);
        },

        playerAttack() {
            if (!this.state.currentMonster) return;
            const p = this.state.player;
            const m = this.state.currentMonster;
            const playerStats = this.calculatePlayerStats();
            const formattedName = this.getFormattedMonsterName(m);

            const playerDamage = Math.max(1, playerStats.attack - Math.floor(m.level / 5));
            m.hp -= playerDamage;
            this.appendOutput(`你對 ${formattedName} 造成了 ${playerDamage} 點傷害！ (怪物剩餘HP: ${m.hp > 0 ? m.hp : 0})`, true);

            if (m.hp <= 0) { this.handleMonsterDefeat(); return; }

            const monsterDamage = Math.max(1, m.attack - playerStats.defense);
            p.hp -= monsterDamage;
            this.appendOutput(`${formattedName} 對你造成了 ${monsterDamage} 點傷害！`, true);
            
            this.updateStatus();
            if (p.hp <= 0) { this.gameOver('你的生命值歸零了。你倒在了地監深處...'); }
        },

        handleMonsterDefeat() {
            const m = this.state.currentMonster;
            const formattedName = this.getFormattedMonsterName(m);
            this.appendOutput(`${formattedName} 被你擊敗了！`, true);

            if (m.monsterType === 'boss') {
                // --- Boss Defeated Logic ---
                this.appendOutput('隨著一聲巨響，強大的氣息煙消雲散，地監恢復了平靜。', true);
                
                const goldEarned = (Math.floor(Math.random() * (m.goldMax - m.goldMin + 1)) + m.goldMin) * 3; // 3x Gold
                this.state.player.gold += goldEarned;
                this.appendOutput(`你獲得了 <span class="text-yellow-400">${goldEarned}</span> 金幣！`, true);

                const xpEarned = m.xpReward * 3; // 3x XP
                this.state.player.xp += xpEarned;
                this.appendOutput(`你獲得了 ${xpEarned} 經驗值！`);

                // Guaranteed high-quality chest
                const chestType = Math.random() < 0.7 ? 'ornate' : 'legendary';
                const chestDisplayNames = { ornate: '華麗寶箱', legendary: '傳說寶箱' };
                const chestName = chestDisplayNames[chestType];
                const formattedChestName = this.getFormattedChestName(chestType, chestName);
                this.appendOutput(`頭目掉落了一個${formattedChestName}！`, true);
                this.openChest(chestType);

            } else {
                // --- Normal Monster Defeated Logic ---
                const goldEarned = Math.floor(Math.random() * (m.goldMax - m.goldMin + 1)) + m.goldMin;
                this.state.player.gold += goldEarned;
                this.appendOutput(`你獲得了 <span class="text-yellow-400">${goldEarned}</span> 金幣！`, true);

                this.state.player.xp += m.xpReward;
                this.appendOutput(`你獲得了 ${m.xpReward} 經驗值！`);

                m.drops?.forEach(drop => {
                    if (Math.random() < drop.chance) {
                        this.state.player.inventory.push(drop.itemKey);
                        this.appendOutput(`你獲得了 ${this.getFormattedItemName(drop.itemKey)}！`, true);
                    }
                });
            }

            this.checkLevelUp();
            this.state.currentMonster = null;
            this.setPhase('explore');
        },

        runAway() {
            const m = this.state.currentMonster;
            if (m && m.monsterType === 'boss') {
                if (Math.random() < 0.3) { // 30% chance to escape boss
                    this.setOutput('你在強大的壓迫感中，驚險地逃跑了！');
                    this.state.currentMonster = null;
                    this.setPhase('explore');
                } else {
                    this.appendOutput('你嘗試從頭目面前逃跑，但失敗了！');
                    const playerStats = this.calculatePlayerStats();
                    const monsterDamage = Math.max(1, m.attack - playerStats.defense);
                    this.state.player.hp -= monsterDamage;
                    this.appendOutput(`${this.getFormattedMonsterName(m)} 對你造成了 ${monsterDamage} 點傷害！`, true);
                    this.updateStatus();
                    if (this.state.player.hp <= 0) { this.gameOver('你的生命值歸零了。你倒在了地監深處...'); }
                }
                return; // End the function here for boss encounters
            }

            // This part is for non-boss monsters
            if (Math.random() < 0.5) {
                this.setOutput('你成功逃跑了！');
                this.state.currentMonster = null;
                this.setPhase('explore');
            } else {
                this.appendOutput('你嘗試逃跑，但失敗了！');
                const playerStats = this.calculatePlayerStats();
                const monsterDamage = Math.max(1, m.attack - playerStats.defense);
                this.state.player.hp -= monsterDamage;
                this.appendOutput(`${this.getFormattedMonsterName(m)} 對你造成了 ${monsterDamage} 點傷害！`, true);
                this.updateStatus();
                if (this.state.player.hp <= 0) { this.gameOver('你的生命值歸零了。你倒在了地監深處...'); }
            }
        },

        checkLevelUp() {
            while (this.state.player.xp >= this.state.player.xpToNextLevel) {
                this.state.player.level++;
                this.state.player.xp -= this.state.player.xpToNextLevel;
                this.state.player.xpToNextLevel = this.getXpRequiredForLevel(this.state.player.level);
                const hpGain = 10, attackGain = 2, defenseGain = 1;
                this.state.player.maxHp += hpGain;
                this.state.player.baseAttack += attackGain;
                this.state.player.baseDefense += defenseGain;
                this.state.player.hp = this.state.player.maxHp;
                this.appendOutput(`恭喜！你升到了等級 ${this.state.player.level}！\n生命上限+${hpGain}, 基礎攻擊+${attackGain}, 基礎防禦+${defenseGain}。`);
            }
        },

        returnToVillage() {
            this.state.player.currentFloor = 1;
            this.state.player.explorationsOnFloor = 0;
            this.saveGame();
            this.setPhase('village');
        },

        restInVillage() {
            if (this.state.player.hp < this.state.player.maxHp) {
                this.state.player.hp = this.state.player.maxHp;
                this.appendOutput(`你在村莊休息，生命值完全恢復了！`);
                this.updateStatus();
            } else { this.appendOutput('你的生命值已經是滿的了。'); }
        },

        gameOver(message) {
            this.deleteSave();
            this.state.gamePhase = 'game_over';
            this.DOM.gameOverMessage.textContent = message;
            this.DOM.gameOverModal.classList.remove('hidden');
            this.renderButtons([]);
            this.updateUI();
        },

        saveGame() {
            try {
                localStorage.setItem('lineageGameSave', JSON.stringify(this.state.player));
                this.appendOutput('<span class="text-green-400">遊戲進度已儲存。</span>', true);
            } catch (e) {
                console.error("存檔失敗:", e);
                this.appendOutput('<span class="text-red-400">存檔失敗，瀏覽器可能已滿或處於隱私模式。</span>', true);
            }
        },

        loadGame() {
            try {
                const savedState = localStorage.getItem('lineageGameSave');
                if (savedState) {
                    this.state.player = JSON.parse(savedState);
                    this.state.currentMonster = null;
                    this.DOM.gameOverModal.classList.add('hidden');
                    this.setOutput('成功載入遊戲進度！你目前在村莊。');
                    this.setPhase('village');
                    return true;
                }
            } catch (e) {
                console.error("讀檔失敗:", e);
                this.appendOutput('<span class="text-red-400">讀取存檔失敗，檔案可能已損毀。</span>', true);
                this.deleteSave();
            }
            return false;
        },

        deleteSave() {
            localStorage.removeItem('lineageGameSave');
        },

        sortItems(itemKeys) {
            const SORT_ORDER = {
                TYPE: { 'potion': 1, 'scroll': 1, 'weapon': 2, 'armor': 2 },
                SLOT: { 'rightHand': 1, 'leftHand': 2, 'head': 3, 'body': 4, 'legs': 5 },
                RARITY: { 'legendary': 4, 'rare': 3, 'uncommon': 2, 'common': 1 }
            };

            return itemKeys.sort((keyA, keyB) => {
                const itemA = this.data.items[keyA];
                const itemB = this.data.items[keyB];

                // 1. Main Category: Consumables (1) > Equipment (2)
                const typeA = SORT_ORDER.TYPE[itemA.type] || 99;
                const typeB = SORT_ORDER.TYPE[itemB.type] || 99;
                if (typeA !== typeB) return typeA - typeB;

                // 2. Equipment Slot (if applicable)
                if (itemA.type === 'weapon' || itemA.type === 'armor') {
                    const slotA = SORT_ORDER.SLOT[itemA.slot] || 99;
                    const slotB = SORT_ORDER.SLOT[itemB.slot] || 99;
                    if (slotA !== slotB) return slotA - slotB;
                }

                // 3. Rarity (Descending)
                const rarityA = SORT_ORDER.RARITY[itemA.rarity || 'common'] || 0;
                const rarityB = SORT_ORDER.RARITY[itemB.rarity || 'common'] || 0;
                if (rarityA !== rarityB) return rarityB - rarityA;

                // 4. Name (Alphabetical)
                return (itemA.name || '').localeCompare(itemB.name || '');
            });
        },

        showInventory() {
            this.state.lastMajorPhase = this.state.gamePhase;
            this.state.gamePhase = 'inventory';
            this.DOM.inventoryDisplay.classList.remove('hidden');
            this.DOM.inventoryDisplay.innerHTML = `<h3 class="text-xl font-bold mb-2 text-center text-gray-300">背包物品</h3><ul id="inventoryListUl"></ul>`;
            this.renderInventory();
            this.renderButtons([{ text: '返回', action: () => this.closeSubmenu() }]);
            this.updateUI();
        },
        renderInventory() {
            const listUl = this.DOM.inventoryDisplay.querySelector('#inventoryListUl');
            listUl.innerHTML = '';
            if (this.state.player.inventory.length === 0) {
                listUl.innerHTML = '<li class="text-center text-gray-400">背包是空的。</li>';
                return;
            }
            const itemCounts = this.state.player.inventory.reduce((acc, key) => {
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});

            const sortedItemKeys = this.sortItems(Object.keys(itemCounts));

            for (const itemKey of sortedItemKeys) {
                const itemData = this.data.items[itemKey];
                const li = document.createElement('li');
                let text = `${this.getFormattedItemName(itemKey)} x${itemCounts[itemKey]}`;
                li.innerHTML = `<span class="item-name">${text}</span>`;
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'item-actions';
                if (itemData.type === 'weapon' || itemData.type === 'armor') {
                    const equipBtn = document.createElement('button');
                    equipBtn.textContent = '裝備';
                    equipBtn.className = 'equip-btn';
                    equipBtn.onclick = () => this.showEquipConfirmation(itemKey);
                    actionsDiv.appendChild(equipBtn);
                }
                if (itemData.type === 'potion' || itemData.type === 'scroll') {
                    const useBtn = document.createElement('button');
                    useBtn.textContent = '使用';
                    useBtn.className = 'use-btn';
                    useBtn.onclick = () => this.useItem(itemKey);
                    actionsDiv.appendChild(useBtn);
                }
                li.appendChild(actionsDiv);
                listUl.appendChild(li);
            }
        },
        closeSubmenu() { this.setPhase(this.state.lastMajorPhase); },
        showEquipConfirmation(itemKeyToEquip) {
            const itemData = this.data.items[itemKeyToEquip];
            const slot = itemData.slot;
            const currentItemKey = this.state.player.equipped[slot];
            const currentItemData = currentItemKey ? this.data.items[currentItemKey] : null;

            this.DOM.equipModalTitle.textContent = `裝備 ${itemData.name}`;

            const attackDiff = (itemData.attack || 0) - (currentItemData?.attack || 0);
            const defenseDiff = (itemData.defense || 0) - (currentItemData?.defense || 0);
            
            let comparisonHTML = `
                <div>
                    <h3>${currentItemKey ? this.getFormattedItemName(currentItemKey) : '無'} (現有)</h3>
                    <p>攻擊: ${currentItemData?.attack || 0}</p>
                    <p>防禦: ${currentItemData?.defense || 0}</p>
                </div>
                <div>
                    <h3>${this.getFormattedItemName(itemKeyToEquip)} (新)</h3>
                    <p>攻擊: ${itemData.attack || 0} <span class="${attackDiff > 0 ? 'stat-change-gain' : attackDiff < 0 ? 'stat-change-loss' : ''}">(${attackDiff > 0 ? '+' : ''}${attackDiff})</span></p>
                    <p>防禦: ${itemData.defense || 0} <span class="${defenseDiff > 0 ? 'stat-change-gain' : defenseDiff < 0 ? 'stat-change-loss' : ''}">(${defenseDiff > 0 ? '+' : ''}${defenseDiff})</span></p>
                </div>`;
            
            this.DOM.equipComparison.innerHTML = comparisonHTML;
            this.DOM.confirmEquipButton.onclick = () => this.equipItem(itemKeyToEquip);
            this.DOM.equipConfirmModal.classList.remove('hidden');
        },
        equipItem(itemKey) {
            const itemData = this.data.items[itemKey];
            const slot = itemData.slot;
            const currentItemKey = this.state.player.equipped[slot];
            if (currentItemKey) { this.state.player.inventory.push(currentItemKey); }
            this.state.player.equipped[slot] = itemKey;
            const index = this.state.player.inventory.indexOf(itemKey);
            if (index > -1) this.state.player.inventory.splice(index, 1);
            this.appendOutput(`你裝備了 ${this.getFormattedItemName(itemKey)}。`, true);
            this.DOM.equipConfirmModal.classList.add('hidden');
            this.updateUI();
            if (this.state.gamePhase === 'inventory') { this.renderInventory(); }
        },
        unequipItem(slotKey) {
            const itemKey = this.state.player.equipped[slotKey];
            if (itemKey) {
                this.state.player.inventory.push(itemKey);
                this.state.player.equipped[slotKey] = null;
                this.appendOutput(`你卸下了 ${this.getFormattedItemName(itemKey)}。`, true);
                this.updateUI();
            }
        },
        useItem(itemKey) {
            const itemData = this.data.items[itemKey];
            if (!itemData.effect) return;
            let used = false;
            if (itemData.effect.type === 'heal') {
                if (this.state.player.hp < this.state.player.maxHp) {
                    this.state.player.hp = Math.min(this.state.player.maxHp, this.state.player.hp + itemData.effect.amount);
                    this.appendOutput(`你使用了 ${itemData.name}，恢復了 ${itemData.effect.amount} 點生命值！`);
                    used = true;
                } else { this.appendOutput('你的生命值已滿。'); }
            } else if (itemData.effect.type === 'teleportHome') {
                this.appendOutput(`你使用了 ${itemData.name}，一道光芒將你傳送回村莊。`);
                this.returnToVillage();
                used = true;
            }
            if (used) {
                const index = this.state.player.inventory.indexOf(itemKey);
                if (index > -1) this.state.player.inventory.splice(index, 1);
                this.updateUI();
                if(this.state.gamePhase === 'inventory') this.renderInventory();
            }
        },

        showShop() {
            this.DOM.shopModal.classList.remove('hidden');
            this.renderButtons([]);
            this.renderShop(this.state.currentShopTab);
        },
        closeShop() {
            this.DOM.shopModal.classList.add('hidden');
            this.setPhase(this.state.lastMajorPhase);
        },
        renderShop(tab) {
            this.state.currentShopTab = tab;
            this.DOM.buyTab.classList.toggle('active', tab === 'buy');
            this.DOM.sellTab.classList.toggle('active', tab === 'sell');
            if (tab === 'buy') { this.renderShopBuyList(); } 
            else { this.renderShopSellList(); }
        },
        renderShopBuyList() {
            const listEl = this.DOM.shopItemList;
            listEl.innerHTML = '';
            this.data.shopInventory.forEach(itemKey => {
                const itemData = this.data.items[itemKey];
                if (!itemData) return;
                const buyPrice = itemData.sell * this.CONSTANTS.SHOP_BUY_PRICE_MULTIPLIER;
                const canAfford = this.state.player.gold >= buyPrice;
                const itemDiv = document.createElement('div');
                itemDiv.className = 'shop-item';
                itemDiv.innerHTML = `
                    <div class="shop-item-info">
                        <div class="shop-item-name">${this.getFormattedItemName(itemKey)}</div>
                        <div class="shop-item-price">價格: ${buyPrice} 金幣</div>
                    </div>
                    <button class="shop-action-btn buy-btn" onclick="Game.buyItem('${itemKey}')" ${canAfford ? '' : 'disabled'}>購買</button>`;
                listEl.appendChild(itemDiv);
            });
        },
        renderShopSellList() {
            const listEl = this.DOM.shopItemList;
            listEl.innerHTML = '';
            const itemCounts = this.state.player.inventory.reduce((acc, key) => {
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});
            
            if (Object.keys(itemCounts).length === 0) {
                listEl.innerHTML = '<div class="text-center text-gray-400 p-4">你的背包是空的。</div>';
                return;
            }

            const sellableItems = Object.keys(itemCounts).filter(key => this.data.items[key] && this.data.items[key].sell);
            const sortedItemKeys = this.sortItems(sellableItems);

            for (const itemKey of sortedItemKeys) {
                const itemData = this.data.items[itemKey];
                if (!itemData || !itemData.sell) continue;
                const itemDiv = document.createElement('div');
                itemDiv.className = 'shop-item';
                itemDiv.innerHTML = `
                    <div class="shop-item-info">
                        <div class="shop-item-name">${this.getFormattedItemName(itemKey)} (x${itemCounts[itemKey]})</div>
                        <div class="shop-item-price">售價: ${itemData.sell} 金幣</div>
                    </div>
                    <button class="shop-action-btn sell-btn" onclick="Game.sellItem('${itemKey}')">販賣</button>`;
                listEl.appendChild(itemDiv);
            }
        },
        buyItem(itemKey) {
            const itemData = this.data.items[itemKey];
            const buyPrice = itemData.sell * this.CONSTANTS.SHOP_BUY_PRICE_MULTIPLIER;
            if (this.state.player.gold >= buyPrice) {
                this.state.player.gold -= buyPrice;
                this.state.player.inventory.push(itemKey);
                this.appendOutput(`你購買了 ${this.getFormattedItemName(itemKey)}。`, true);
                this.updateUI();
                this.renderShop('buy');
            } else { this.appendOutput('你的金幣不足！'); }
        },
        sellItem(itemKey) {
            const itemData = this.data.items[itemKey];
            const index = this.state.player.inventory.indexOf(itemKey);
            if (index > -1) {
                this.state.player.inventory.splice(index, 1);
                this.state.player.gold += itemData.sell;
                this.appendOutput(`你賣掉了 ${this.getFormattedItemName(itemKey)}，獲得了 ${itemData.sell} 金幣。`, true);
                this.updateUI();
                this.renderShop('sell');
            }
        },

        getFormattedMonsterName(monster) {
            if (!monster) return '';
            const rarity = monster.rarity || 'common';
            const colorClass = {
                common: 'text-gray-300',
                uncommon: 'text-green-400',
                rare: 'text-blue-400',
                legendary: 'text-red-400'
            }[rarity];
            return `<span class="${colorClass}">${monster.name}</span>`;
        },
        getFormattedChestName(chestType, chestName) {
            const rarityColorMap = {
                wooden: 'text-gray-300',    // Common
                sturdy: 'text-green-400',  // Uncommon
                ornate: 'text-blue-400',    // Rare
                legendary: 'text-red-400'   // Legendary
            };
            const colorClass = rarityColorMap[chestType] || 'text-gray-300';
            return `<span class="${colorClass}">${chestName}</span>`;
        },
        getFormattedItemName(itemKey) {
            const itemData = this.data.items[itemKey];
            if (!itemData) return '';
            const rarity = itemData.rarity || 'common';
            const colorClass = {
                common: 'text-gray-300',
                uncommon: 'text-green-400',
                rare: 'text-blue-400',
                legendary: 'text-red-400'
            }[rarity];
            return `<span class="${colorClass}">${itemData.name}</span>`;
        },
        calculatePlayerStats() {
            const p = this.state.player;
            let totalAttack = p.baseAttack;
            let totalDefense = p.baseDefense;
            for (const slot in p.equipped) {
                const itemKey = p.equipped[slot];
                if (itemKey && this.data.items[itemKey]) {
                    const itemData = this.data.items[itemKey];
                    totalAttack += itemData.attack || 0;
                    totalDefense += itemData.defense || 0;
                }
            }
            return { attack: totalAttack, defense: totalDefense };
        },
        getXpRequiredForLevel(level) { return Math.floor(100 + (level - 1) * 50); },
        
        appendOutput(message, isHTML = false) {
            const output = this.DOM.gameOutput;
            const lineBreak = output.innerHTML.length > 0 ? '<br>' : '';
            if (isHTML) {
                output.innerHTML += lineBreak + message;
            } else {
                output.innerHTML += lineBreak + message.replace(/\n/g, '<br>');
            }
            output.scrollTop = output.scrollHeight;
        },
        setOutput(message, isHTML = false) {
            const output = this.DOM.gameOutput;
            if (isHTML) {
                output.innerHTML = message;
            } else {
                output.textContent = message;
            }
            output.scrollTop = output.scrollHeight;
        },
    };

    // **修改**：改為非同步的初始化呼叫
    window.onload = () => {
        Game.init();
    };
    </script>
</body>
</html>
